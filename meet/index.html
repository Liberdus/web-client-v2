<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Liberdus Video Call</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- Socket.IO Client -->
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    
    <style>
        /* Custom styles for a better look and feel */
        body {
            font-family: 'Inter', sans-serif;
        }
        #video-grid {
            display: flex; /* switched from CSS grid to flex for algorithmic sizing */
            flex-wrap: wrap;
            align-content: flex-start; /* pack rows at the top */
            width: 100%;
            height: 100%;
            /* gap set dynamically via JS to keep math consistent with layout algorithm */
            box-sizing: border-box;
        }
        video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 0.5rem;
            transform: scaleX(-1); /* Mirror effect for self-view */
        }
        .video-container {
            position: relative;
            background-color: #000; /* pure black, reduces grey letterboxing perception */
            border-radius: 0.5rem;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transition: width 150ms ease, height 150ms ease; /* smooth resize */
        }
        .video-container > video { flex: 1 1 auto; width:100%; height:100%; object-fit: cover; }
        .video-container.active-speaker { box-shadow: 0 0 0 3px #22c55e, 0 0 16px 4px rgba(34,197,94,0.5); }
        .video-container.pinned { box-shadow: 0 0 0 3px #3b82f6, 0 0 18px 6px rgba(59,130,246,0.4); }
        #stage-area .pinned-video-wrapper { position: relative; width:100%; height:100%; display:flex; align-items:center; justify-content:center; }
        #stage-area .pinned-video-wrapper video { width:100%; height:100%; object-fit:cover; }
        #filmstrip-wrapper.stage-mode { flex: 0 0 320px; max-width:320px; border-left:1px solid #1f2937; background:#111827; overflow-y:auto; }
        #filmstrip-wrapper.stage-mode #video-grid { display:flex; flex-direction:column; align-content:stretch; align-items:stretch; flex-wrap:nowrap; overflow-y:auto; }
        #filmstrip-wrapper.stage-mode #video-grid .video-container { flex:0 0 auto; width:100%!important; height:180px!important; margin:0 0 8px 0!important; }
        #filmstrip-wrapper.stage-mode #video-grid .video-container:last-child { margin-bottom:0; }
        .pin-btn { opacity:0; transition:opacity .15s ease; }
        .video-container:hover .pin-btn { opacity:1; }
        .pinned-badge { position:absolute; top:8px; left:8px; background:#3b82f6; color:#fff; font-size:10px; padding:2px 6px; border-radius:12px; letter-spacing:.5px; text-transform:uppercase; }
        /* When we are animating container width (chat slide) we disable tile transitions
           to prevent intermediate wrap causing flicker. */
        .suspend-tile-anim .video-container { transition: none !important; }
        .participant-name {
            position: absolute;
            bottom: 8px;
            left: 8px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.875rem;
        }
        .control-btn.active {
            background-color: #4A90E2;
            color: white;
        }
        .control-btn.danger {
            background-color: #D0021B;
            color: white;
        }
        #chat-panel {
            transition: transform 0.3s ease-in-out;
        }
        .chat-message {
            max-width: 80%;
        }
        .my-message {
            align-self: flex-end;
            background-color: #4A90E2;
            color: white;
        }
        .other-message {
            align-self: flex-start;
            background-color: #4A4A4A;
            color: white;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col h-screen overflow-hidden">

    <!-- Main Content -->
    <main class="flex-1 relative overflow-hidden"> <!-- make relative for absolute chat -->
        <!-- Chat Panel (Left Sliding) -->
        <aside id="chat-panel" class="w-80 bg-gray-800 flex flex-col h-full absolute top-0 left-0 -translate-x-full transition-transform duration-300 z-20 shadow-xl">
            <div class="p-4 border-b border-gray-700 flex justify-between items-center">
                <h2 class="text-xl font-semibold">Chat</h2>
                <button id="close-chat-btn" class="p-1 rounded-full hover:bg-gray-700">
                    <i data-lucide="x"></i>
                </button>
            </div>
            <div id="chat-messages" class="flex-1 p-4 overflow-y-auto flex flex-col space-y-2"></div>
            <div class="p-4 border-t border-gray-700">
                <form id="chat-form" class="flex space-x-2">
                    <input type="text" id="chat-input" placeholder="Type a message..." class="flex-1 bg-gray-700 rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <button type="submit" class="bg-blue-600 hover:bg-blue-700 p-2 rounded-md">
                        <i data-lucide="send"></i>
                    </button>
                </form>
            </div>
        </aside>

        <!-- Video / Stage Layout Wrapper -->
        <div id="video-area" class="h-full w-full transition-all duration-300 flex flex-col"> <!-- video area spans full, will shift when chat shows -->
            <div id="call-layout" class="flex flex-1 overflow-hidden">
                <!-- Stage Area (shown when a participant is pinned) -->
                <div id="stage-area" class="hidden relative flex-1 bg-black items-center justify-center overflow-hidden">
                    <!-- Large pinned video inserted here -->
                </div>
                <!-- Filmstrip / Grid Container -->
                <div id="filmstrip-wrapper" class="flex-1 flex overflow-hidden"> 
                    <div id="video-grid" class="w-full h-full">
                        <!-- Local video will be appended here -->
                        <div class="video-container" id="local-video-container" data-participant-id="local" data-is-local="true">
                            <video id="local-video" autoplay muted></video>
                            <div class="participant-name flex items-center gap-1"><span>You</span></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Controls Bar -->
    <footer class="bg-gray-800 p-4 flex justify-center items-center space-x-4">
        <button id="mic-btn" class="control-btn p-3 bg-gray-700 rounded-full hover:bg-gray-600 active">
            <i data-lucide="mic"></i>
        </button>
        <button id="video-btn" class="control-btn p-3 bg-gray-700 rounded-full hover:bg-gray-600 active">
            <i data-lucide="video"></i>
        </button>
        <button id="screen-share-btn" class="control-btn p-3 bg-gray-700 rounded-full hover:bg-gray-600">
            <i data-lucide="screen-share"></i>
        </button>
        <button id="chat-btn" class="control-btn p-3 bg-gray-700 rounded-full hover:bg-gray-600">
            <i data-lucide="message-square"></i>
        </button>
        <button id="tile-view-btn" class="control-btn p-3 bg-gray-700 rounded-full hover:bg-gray-600" title="Return to Tile View">
            <i data-lucide="layout-grid"></i>
        </button>
        <button id="leave-btn" class="control-btn danger p-3 rounded-full hover:bg-red-700">
            <i data-lucide="phone-off"></i>
        </button>
    </footer>

    <!-- Room Entry Modal -->
    <div id="room-modal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
        <div class="bg-gray-800 p-8 rounded-lg shadow-xl text-center">
            <h1 class="text-3xl font-bold mb-4">Liberdus Meet</h1>
            <p class="mb-6 text-gray-400">Enter a room name to join or create a call.</p>
            <form id="room-form">
                <input type="text" id="room-id-input" placeholder="e.g., project-kickoff" class="w-full bg-gray-700 text-white p-3 rounded-md mb-4 focus:outline-none focus:ring-2 focus:ring-blue-500 text-center">
                <button type="submit" class="w-full bg-blue-600 hover:bg-blue-700 p-3 rounded-md font-semibold">Join Room</button>
            </form>
        </div>
    </div>


    <script>
        // Initialize Lucide Icons
        lucide.createIcons();

        // --- DOM Elements ---
        const videoGrid = document.getElementById('video-grid');
        const localVideo = document.getElementById('local-video');
        const roomModal = document.getElementById('room-modal');
        const roomForm = document.getElementById('room-form');
        const roomIdInput = document.getElementById('room-id-input');
        
        const micBtn = document.getElementById('mic-btn');
        const videoBtn = document.getElementById('video-btn');
        const screenShareBtn = document.getElementById('screen-share-btn');
        const leaveBtn = document.getElementById('leave-btn');
        const chatBtn = document.getElementById('chat-btn');
        const closeChatBtn = document.getElementById('close-chat-btn');
        const chatPanel = document.getElementById('chat-panel');
        const videoArea = document.getElementById('video-area');
        const chatForm = document.getElementById('chat-form');
        const chatInput = document.getElementById('chat-input');
        const chatMessages = document.getElementById('chat-messages');
        const tileViewBtn = document.getElementById('tile-view-btn');

        // --- Globals ---
        // IMPORTANT: We now connect over HTTPS
        const SERVER_URL = 'https://arimaa.com:3000'; 
        const socket = io(SERVER_URL);
        
        let localStream;
        let screenStream;
        let isScreenSharing = false;
        let roomId;
        const peers = {}; // To store peer connections: { socketId: RTCPeerConnection }

        /******************** Participant / Stage / Active Speaker State ********************/
        const participants = new Map(); // id -> { id, container, videoEl, stream, isLocal, analyser, energy }
        let pinnedParticipantId = null; // currently pinned participant (id)
        let activeSpeakerId = null;    // currently detected active speaker (id)
        let stageMode = 'none';        // 'none' | 'auto' | 'pinned'
        let previousNonScreenStageMode = 'none'; // remember what mode we were in before forcing screen share stage
        const activeScreenSharers = new Set();
        let lastScreenSharerId = null;
        let audioContext = null;       // shared AudioContext (lazy)
        let activeSpeakerInterval = null;

        function registerLocalParticipant() {
            const container = document.getElementById('local-video-container');
            if (!container) return;
            const videoEl = container.querySelector('video');
            participants.set('local', { id: 'local', container, videoEl, stream: localStream, isLocal: true, analyser: null, energy: 0 });
            setupAudioAnalyser('local');
        }

        function registerRemoteParticipant(userId, stream) {
            const videoEl = document.getElementById(userId);
            if (!videoEl) return; // should exist
            const container = videoEl.parentElement;
            container.dataset.participantId = userId;
            participants.set(userId, { id: userId, container, videoEl, stream, isLocal: false, analyser: null, energy: 0 });
            setupAudioAnalyser(userId);
        }

        function unregisterParticipant(userId) {
            participants.delete(userId);
            if (pinnedParticipantId === userId) {
                unpinParticipant();
            }
            if (activeSpeakerId === userId) {
                setActiveSpeaker(null);
            }
        }

        function attachPinButton() { /* deprecated: click-to-pin now */ }

        /******************** Stage / Pin Logic ********************/
        function pinParticipant(id) {
            if (!participants.has(id)) return;
            pinnedParticipantId = id;
            stageMode = 'pinned';
            applyStageLayout();
        }

        function unpinParticipant({ preserveAuto = false } = {}) {
            pinnedParticipantId = null;
            if (preserveAuto && stageMode !== 'none') {
                stageMode = 'auto';
            } else {
                stageMode = 'none';
            }
            applyStageLayout();
        }

        function applyStageLayout() {
            const stageArea = document.getElementById('stage-area');
            const filmstripWrapper = document.getElementById('filmstrip-wrapper');
            const wantsStage = stageMode !== 'none';

            if (wantsStage) {
                stageArea.classList.remove('hidden');
                filmstripWrapper.classList.add('stage-mode');
                // Ensure wrapper + stage video exist
                let wrapper = stageArea.querySelector('.pinned-video-wrapper');
                if (!wrapper) {
                    wrapper = document.createElement('div');
                    wrapper.className = 'pinned-video-wrapper w-full h-full relative';
                    stageArea.innerHTML = '';
                    stageArea.appendChild(wrapper);
                }
                let stageVideo = wrapper.querySelector('video');
                if (!stageVideo) {
                    stageVideo = document.createElement('video');
                    stageVideo.autoplay = true;
                    stageVideo.playsInline = true;
                    stageVideo.style.width = '100%';
                    stageVideo.style.height = '100%';
                    stageVideo.style.objectFit = 'cover';
                    wrapper.appendChild(stageVideo);
                }

                let streamSourceParticipant = null;
                if (stageMode === 'pinned' && pinnedParticipantId && participants.has(pinnedParticipantId)) {
                    streamSourceParticipant = participants.get(pinnedParticipantId);
                } else if (stageMode === 'auto') {
                    if (activeSpeakerId && participants.has(activeSpeakerId)) {
                        streamSourceParticipant = participants.get(activeSpeakerId);
                    } else {
                        // fallback first participant
                        const first = participants.values().next().value;
                        if (first) streamSourceParticipant = first;
                    }
                }
                if (streamSourceParticipant && streamSourceParticipant.stream) {
                    stageVideo.srcObject = streamSourceParticipant.stream;
                    stageVideo.muted = !!streamSourceParticipant.isLocal; // mute if local
                    const isScreen = isScreenShareStream(streamSourceParticipant.stream, streamSourceParticipant.id === 'local');
                    if (isScreen) {
                        stageVideo.style.objectFit = 'contain'; // ensure full screen visible (no cropping)
                        stageVideo.style.backgroundColor = '#000';
                        stageVideo.style.transform = 'none';
                    } else {
                        stageVideo.style.objectFit = 'cover';
                        stageVideo.style.backgroundColor = 'transparent';
                        if (streamSourceParticipant.isLocal) {
                            stageVideo.style.transform = 'scaleX(-1)';
                        } else {
                            stageVideo.style.transform = 'none';
                        }
                    }
                }

                // Visual badges/classes only for pinned mode
                participants.forEach(p => {
                    if (stageMode === 'pinned' && p.id === pinnedParticipantId) {
                        p.container.classList.add('pinned');
                        addOrUpdatePinnedBadge(p.container);
                    } else {
                        p.container.classList.remove('pinned');
                        removePinnedBadge(p.container);
                    }
                });
            } else {
                stageArea.classList.add('hidden');
                filmstripWrapper.classList.remove('stage-mode');
                participants.forEach(p => { p.container.classList.remove('pinned'); removePinnedBadge(p.container); });
            }
            debouncedAdjustGrid();
        }

        function isScreenShareStream(stream, isLocal) {
            if (!stream) return false;
            if (isLocal && isScreenSharing) return true; // authoritative for local
            const tracks = stream.getVideoTracks ? stream.getVideoTracks() : [];
            if (!tracks.length) return false;
            const track = tracks[0];
            try {
                const settings = track.getSettings ? track.getSettings() : {};
                if (settings.displaySurface) return true; // monitor/window/application/browser
            } catch {}
            const label = (track.label || '').toLowerCase();
            if (label.includes('screen') || label.includes('window') || label.includes('share') || label.includes('display')) return true;
            return false;
        }

        function addOrUpdatePinnedBadge(container) {
            let badge = container.querySelector('.pinned-badge');
            if (!badge) {
                badge = document.createElement('div');
                badge.className = 'pinned-badge flex items-center gap-1';
                badge.innerHTML = '<span class="text-[10px] uppercase tracking-wide">Pinned</span>';
                container.appendChild(badge);
            }
        }

        function removePinnedBadge(container) {
            const badge = container.querySelector('.pinned-badge');
            if (badge) badge.remove();
        }

        /******************** Active Speaker Detection ********************/
        function setupAudioAnalyser(id) {
            const participant = participants.get(id);
            if (!participant || !participant.stream) return;
            const audioTracks = participant.stream.getAudioTracks();
            if (!audioTracks.length) return;
            try {
                if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaStreamSource(participant.stream);
                const analyser = audioContext.createAnalyser();
                analyser.fftSize = 256; // small for lightweight processing
                source.connect(analyser);
                participant.analyser = analyser;
                participant.dataArray = new Uint8Array(analyser.frequencyBinCount);
            } catch (e) {
                console.warn('Audio analyser setup failed for', id, e);
            }
        }

        function startActiveSpeakerLoop() {
            if (activeSpeakerInterval) return;
            activeSpeakerInterval = setInterval(runActiveSpeakerDetection, 350);
        }

        function runActiveSpeakerDetection() {
            let bestId = null;
            let bestEnergy = 0.0;
            participants.forEach(p => {
                if (!p.analyser) return;
                p.analyser.getByteFrequencyData(p.dataArray);
                // Compute simple average energy in [0,1]
                let sum = 0;
                for (let i = 0; i < p.dataArray.length; i++) sum += p.dataArray[i];
                const energy = sum / (p.dataArray.length * 255);
                p.energy = energy;
                if (energy > bestEnergy) {
                    bestEnergy = energy;
                    bestId = p.id;
                }
            });
            const THRESHOLD = 0.08; // empirical small-room threshold
            if (bestEnergy < THRESHOLD) {
                // Silence; keep current unless it's been silent for a while
                return;
            }
            if (bestId && bestId !== activeSpeakerId) {
                setActiveSpeaker(bestId);
            }
        }

        function setActiveSpeaker(id) {
            if (activeSpeakerId && participants.has(activeSpeakerId)) {
                participants.get(activeSpeakerId).container.classList.remove('active-speaker');
            }
            activeSpeakerId = id;
            if (id && participants.has(id)) {
                participants.get(id).container.classList.add('active-speaker');
            }
            if (stageMode === 'auto') {
                applyStageLayout(); // refresh stage stream to new speaker
            }
        }

        /******************** Tile Click Behavior ********************/
        document.addEventListener('click', (e) => {
            const container = e.target.closest('.video-container');
            if (!container || !videoGrid.contains(container)) return;
            const id = container.dataset.participantId;
            if (!id) return;
            if (stageMode === 'none') {
                // Grid -> pin directly
                pinParticipant(id);
                return;
            }
            if (stageMode === 'auto') {
                // Auto -> pin chosen
                pinParticipant(id);
                return;
            }
            if (stageMode === 'pinned') {
                if (pinnedParticipantId === id) {
                    // Clicking pinned participant switches to auto mode
                    pinnedParticipantId = null;
                    stageMode = 'auto';
                    applyStageLayout();
                } else {
                    // Pin another participant
                    pinParticipant(id);
                }
            }
        });

        // --- WebRTC Configuration ---
        const peerConnectionConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                // In a production environment, you would add TURN servers here
            ]
        };

        // --- Core Logic ---

        // Check for room in URL on page load
        window.addEventListener('load', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const roomFromUrl = urlParams.get('room');

            if (roomFromUrl) {
                roomId = roomFromUrl.trim();
                roomIdInput.value = roomId; // Pre-fill the input just in case
                roomModal.style.display = 'none';
                init(); // Automatically start the call
            }
        });

        // 1. Join Room
        roomForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            roomId = roomIdInput.value.trim();
            if (roomId) {
                roomModal.style.display = 'none';
                // Update URL to reflect joined room without reloading the page
                try {
                    const newUrl = `${window.location.pathname}?room=${encodeURIComponent(roomId)}`;
                    window.history.replaceState({ room: roomId }, '', newUrl);
                } catch (err) {
                    console.warn('Failed to update URL with room id', err);
                }
                await init();
            }
        });

        async function init() {
            try {
                // Get user media
                localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                localVideo.srcObject = localStream;
                registerLocalParticipant();
                startActiveSpeakerLoop();
                debouncedAdjustGrid();

                // Join the room
                socket.emit('join-room', roomId);

                setupSocketListeners();
                setupControlEvents();

            } catch (error) {
                console.error('Error initializing:', error);
                alert("Could not access camera and microphone. Please check permissions and ensure you are on a secure (HTTPS) connection.");
                roomModal.style.display = 'flex';
            }
        }

        // 2. Socket Listeners
        function setupSocketListeners() {
            socket.on('user-connected', (userId) => {
                console.log(`New user connected: ${userId}`);
                // Create a new peer connection for the new user
                const peerConnection = createPeerConnection(userId);
                // Create an offer to send to the new user
                peerConnection.createOffer()
                    .then(offer => {
                        return peerConnection.setLocalDescription(offer);
                    })
                    .then(() => {
                        socket.emit('offer', { target: userId, offer: peerConnection.localDescription });
                    })
                    .catch(e => console.error('Offer creation error:', e));
            });

            socket.on('offer', ({ from, offer }) => {
                console.log(`Received offer from: ${from}`);
                const peerConnection = createPeerConnection(from);
                peerConnection.setRemoteDescription(new RTCSessionDescription(offer))
                    .then(() => peerConnection.createAnswer())
                    .then(answer => {
                        return peerConnection.setLocalDescription(answer);
                    })
                    .then(() => {
                        socket.emit('answer', { target: from, answer: peerConnection.localDescription });
                    })
                    .catch(e => console.error('Answer creation error:', e));
            });

            socket.on('answer', ({ from, answer }) => {
                console.log(`Received answer from: ${from}`);
                const peerConnection = peers[from];
                if (peerConnection) {
                    peerConnection.setRemoteDescription(new RTCSessionDescription(answer))
                        .catch(e => console.error('Set remote description error:', e));
                }
            });

            socket.on('ice-candidate', ({ from, candidate }) => {
                console.log(`Received ICE candidate from: ${from}`);
                const peerConnection = peers[from];
                if (peerConnection && candidate) {
                    peerConnection.addIceCandidate(new RTCIceCandidate(candidate))
                        .catch(e => console.error('Add ICE candidate error:', e));
                }
            });

            socket.on('user-disconnected', (userId) => {
                console.log(`User disconnected: ${userId}`);
                if (peers[userId]) {
                    peers[userId].close();
                    delete peers[userId];
                }
                const videoElement = document.getElementById(userId);
                if (videoElement) {
                    videoElement.parentElement.remove();
                    debouncedAdjustGrid();
                }
                unregisterParticipant(userId);
            });
            
            socket.on('chat-message', ({ from, message }) => {
                appendChatMessage(message, 'other');
            });

            socket.on('screen-share-started', ({ from }) => {
                activeScreenSharers.add(from);
                lastScreenSharerId = from;
                if (!pinnedParticipantId) previousNonScreenStageMode = stageMode;
                // If their participant object already exists, stage immediately
                if (participants.has(from)) {
                    pinnedParticipantId = from;
                    stageMode = 'pinned';
                    applyStageLayout();
                } else {
                    // Delay until track arrives: poll briefly
                    let attempts = 0;
                    const interval = setInterval(() => {
                        attempts++;
                        if (participants.has(from) || attempts > 20) {
                            clearInterval(interval);
                            if (participants.has(from)) {
                                pinnedParticipantId = from;
                                stageMode = 'pinned';
                                applyStageLayout();
                            }
                        }
                    }, 250);
                }
            });

            socket.on('screen-share-stopped', ({ from }) => {
                activeScreenSharers.delete(from);
                if (activeScreenSharers.size > 0) {
                    // Switch to another still-active sharer (most recent)
                    const next = Array.from(activeScreenSharers).slice(-1)[0];
                    if (participants.has(next)) {
                        pinnedParticipantId = next;
                        stageMode = 'pinned';
                        applyStageLayout();
                    }
                } else {
                    // Restore pre-share mode
                    pinnedParticipantId = null;
                    stageMode = previousNonScreenStageMode;
                    if (stageMode === 'pinned') {
                        // If previous mode was pinned but we lost pinned target, fallback to auto
                        if (!pinnedParticipantId) stageMode = 'auto';
                    }
                    if (stageMode === 'none') {
                        applyStageLayout();
                    } else {
                        applyStageLayout();
                    }
                }
            });
        }

        // 3. WebRTC Peer Connection
        function createPeerConnection(targetUserId) {
            const peerConnection = new RTCPeerConnection(peerConnectionConfig);
            peers[targetUserId] = peerConnection;

            // Add local stream tracks to the connection
            const streamToUse = isScreenSharing ? screenStream : localStream;
            streamToUse.getTracks().forEach(track => {
                peerConnection.addTrack(track, streamToUse);
            });

            // Handle incoming tracks from the remote peer
            peerConnection.ontrack = (event) => {
                let videoElement = document.getElementById(targetUserId);
                if (!videoElement) {
                    const videoContainer = document.createElement('div');
                    videoContainer.classList.add('video-container');
                    videoContainer.dataset.participantId = targetUserId;
                    
                    videoElement = document.createElement('video');
                    videoElement.id = targetUserId;
                    videoElement.autoplay = true;
                    videoElement.style.transform = 'scaleX(-1)'; // Mirror remote videos too for consistency

                    const nameTag = document.createElement('div');
                    nameTag.classList.add('participant-name');
                    nameTag.textContent = `User ${targetUserId.substring(0, 6)}`;

                    videoContainer.appendChild(videoElement);
                    videoContainer.appendChild(nameTag);
                    videoGrid.appendChild(videoContainer);
                    debouncedAdjustGrid();
                }
                videoElement.srcObject = event.streams[0];
                // Register (or update) remote participant with audio analyser
                if (!participants.has(targetUserId)) {
                    registerRemoteParticipant(targetUserId, event.streams[0]);
                } else {
                    const p = participants.get(targetUserId);
                    p.stream = event.streams[0];
                    setupAudioAnalyser(targetUserId);
                }
            };

            // Handle ICE candidates
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    socket.emit('ice-candidate', { target: targetUserId, candidate: event.candidate });
                }
            };

            return peerConnection;
        }
        
        // 4. UI Controls
        function setupControlEvents() {
            micBtn.addEventListener('click', () => {
                const enabled = localStream.getAudioTracks()[0].enabled;
                localStream.getAudioTracks()[0].enabled = !enabled;
                micBtn.classList.toggle('active', !enabled);
                micBtn.innerHTML = enabled ? '<i data-lucide="mic-off"></i>' : '<i data-lucide="mic"></i>';
                lucide.createIcons();
            });

            videoBtn.addEventListener('click', () => {
                if(isScreenSharing) return; // Don't allow toggling video while screen sharing
                const enabled = localStream.getVideoTracks()[0].enabled;
                localStream.getVideoTracks()[0].enabled = !enabled;
                videoBtn.classList.toggle('active', !enabled);
                videoBtn.innerHTML = enabled ? '<i data-lucide="video-off"></i>' : '<i data-lucide="video"></i>';
                lucide.createIcons();
            });

            screenShareBtn.addEventListener('click', toggleScreenSharing);
            tileViewBtn.addEventListener('click', () => {
                if (stageMode === 'none') {
                    // Enter auto speaker stage mode
                    stageMode = 'auto';
                    applyStageLayout();
                } else if (stageMode === 'auto') {
                    // Leave stage entirely
                    stageMode = 'none';
                    applyStageLayout();
                } else if (stageMode === 'pinned') {
                    // From pinned -> exit to auto speaker mode
                    pinnedParticipantId = null;
                    stageMode = 'auto';
                    applyStageLayout();
                }
            });

            leaveBtn.addEventListener('click', () => {
                try {
                    // Gracefully close all peer connections
                    Object.keys(peers).forEach(id => {
                        try { peers[id].close(); } catch {}
                        delete peers[id];
                    });
                    // Stop local media tracks
                    if (localStream) {
                        localStream.getTracks().forEach(t => { try { t.stop(); } catch {} });
                    }
                    if (screenStream) {
                        screenStream.getTracks().forEach(t => { try { t.stop(); } catch {} });
                    }
                    // Inform server we're leaving (optional; no specific event defined, so just disconnect)
                    try { socket.disconnect(); } catch {}
                } catch (e) {
                    console.warn('Error during leave cleanup', e);
                }
                // Attempt to close the window/tab (will only succeed if user opened it via script or browser allows)
                window.open('', '_self'); // Helps some browsers allow close()
                window.close();
                // Fallback: navigate to a blank page if close is blocked
                setTimeout(() => {
                    if (!document.hidden) {
                        window.location.href = 'about:blank';
                    }
                }, 150);
            });

            const CHAT_WIDTH = 320; // px (w-80)
            let chatOpen = false;
            let layoutSuppressedUntil = 0;

            function computeLayoutForWidth(explicitWidthPx) {
                const tiles = videoGrid.querySelectorAll('.video-container');
                const participantCount = tiles.length;
                if (!participantCount) return;
                const viewportHeight = videoGrid.getBoundingClientRect().height; // current height remains
                const viewportWidth = explicitWidthPx; // pretend final width

                // Reuse existing logic but pass temporary width via direct variable override
                if (participantCount <= 3) {
                    const gapX = layoutConfig.horizontalGap;
                    const totalGapWidth = gapX * (participantCount - 1);
                    const tileWidth = (viewportWidth - totalGapWidth) / participantCount;
                    const tileHeight = viewportHeight;
                    tiles.forEach(t => { t.style.width = tileWidth + 'px'; t.style.height = tileHeight + 'px'; });
                    return;
                }
                const layout = computeResponsiveGrid({
                    participantCount,
                    viewportWidth,
                    viewportHeight,
                    config: layoutConfig
                });
                tiles.forEach(t => { t.style.width = layout.tileWidth + 'px'; t.style.height = layout.tileHeight + 'px'; });
            }

            function openChat() {
                chatOpen = true;
                // Disable transitions on tiles to avoid flicker
                document.body.classList.add('suspend-tile-anim');
                // Precompute layout for the target width BEFORE animating panel slide
                const finalWidth = videoArea.parentElement.clientWidth - CHAT_WIDTH; // parent width minus panel
                computeLayoutForWidth(finalWidth);
                // Now start animation (panel slides in, video area shifts but tiles already sized for final width)
                videoArea.style.marginLeft = CHAT_WIDTH + 'px';
                videoArea.style.width = finalWidth + 'px';
                chatPanel.classList.remove('-translate-x-full');
                // After animation completes (~300ms) re-enable transitions and do a safety adjust
                setTimeout(() => {
                    document.body.classList.remove('suspend-tile-anim');
                    adjustGrid();
                }, 320);
            }
            function closeChat() {
                chatOpen = false;
                document.body.classList.add('suspend-tile-anim');
                chatPanel.classList.add('-translate-x-full');
                videoArea.style.marginLeft = '0px';
                videoArea.style.width = '100%';
                // Adjust after frame for restored full width
                requestAnimationFrame(() => {
                    adjustGrid();
                    requestAnimationFrame(() => document.body.classList.remove('suspend-tile-anim'));
                });
            }
            chatBtn.addEventListener('click', () => {
                chatOpen ? closeChat() : openChat();
            });
            closeChatBtn.addEventListener('click', () => {
                if (chatOpen) closeChat();
            });
            
            chatForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const message = chatInput.value.trim();
                if (message) {
                    socket.emit('chat-message', message);
                    appendChatMessage(message, 'my');
                    chatInput.value = '';
                }
            });
        }

        async function toggleScreenSharing() {
            if (!isScreenSharing) {
                try {
                    screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
                    isScreenSharing = true;
                    
                    // Replace video track for all peers
                    for (const peerId in peers) {
                        const sender = peers[peerId].getSenders().find(s => s.track.kind === 'video');
                        if (sender) {
                            sender.replaceTrack(screenStream.getVideoTracks()[0]);
                        }
                    }

                    localVideo.srcObject = screenStream;
                    const localParticipant = participants.get('local');
                    if (localParticipant) {
                        localParticipant.stream = screenStream;
                    }
                    // Remove mirror effect for screen share in local tile
                    localVideo.style.transform = 'none';
                    // Style: dedicated screen-sharing state (solid red always)
                    screenShareBtn.classList.remove('active','bg-gray-700','hover:bg-gray-600','hover:bg-red-700');
                    screenShareBtn.classList.add('danger','hover:bg-red-700');
                    // Update icon while sharing
                    screenShareBtn.innerHTML = '<i data-lucide="screen-share-off"></i>';
                    lucide.createIcons();

                    // Force stage view to show this screen if not already in a screen-forced stage
                    if (!anyScreenShareActive()) {
                        previousNonScreenStageMode = stageMode; // remember
                    }
                    // Enter pinned stage focusing local sharer (treat as pinned for stability)
                    pinnedParticipantId = 'local';
                    stageMode = 'pinned';
                    applyStageLayout();

                    // Notify others that screen sharing started
                    socket.emit('screen-share-started', { from: socket.id });

                    // When user stops sharing via browser UI
                    screenStream.getVideoTracks()[0].onended = () => {
                        stopScreenSharing();
                    };

                } catch (error) {
                    console.error('Error starting screen share:', error);
                }
            } else {
                stopScreenSharing();
            }
        }

        function stopScreenSharing() {
            if (!isScreenSharing) return;

            // Revert to camera track for all peers
            for (const peerId in peers) {
                const sender = peers[peerId].getSenders().find(s => s.track.kind === 'video');
                if (sender) {
                    sender.replaceTrack(localStream.getVideoTracks()[0]);
                }
            }

            screenStream.getTracks().forEach(track => track.stop());
            localVideo.srcObject = localStream;
            const localParticipant = participants.get('local');
            if (localParticipant) {
                localParticipant.stream = localStream;
            }
            // Restore mirror for camera self-view
            localVideo.style.transform = 'scaleX(-1)';
            isScreenSharing = false;
            screenShareBtn.classList.remove('danger');
            // Revert button styling/icon
            screenShareBtn.classList.remove('hover:bg-red-700');
            screenShareBtn.classList.add('bg-gray-700','hover:bg-gray-600');
            screenShareBtn.innerHTML = '<i data-lucide="screen-share"></i>';
            lucide.createIcons();
            if (!anyScreenShareActive()) {
                // No more screen shares anywhere; restore previous mode
                if (previousNonScreenStageMode === 'none') {
                    stageMode = 'none';
                    pinnedParticipantId = null;
                } else {
                    stageMode = previousNonScreenStageMode;
                    if (stageMode !== 'pinned') pinnedParticipantId = null;
                }
                applyStageLayout();
            } else {
                // Another participant still sharing; refresh stage (it will switch to them on next detection cycle if needed)
                applyStageLayout();
            }
            // Notify others
            socket.emit('screen-share-stopped', { from: socket.id });
        }

        function anyScreenShareActive() {
            for (const p of participants.values()) {
                if (isScreenShareStream(p.stream, p.id === 'local')) return true;
            }
            return false;
        }

        // Enhance active speaker detection loop to prioritize screen shares: if any screen share is active, keep stage focused on it (first found or pinned)
        const _origRunActiveSpeakerDetection = runActiveSpeakerDetection;
        runActiveSpeakerDetection = function() {
            // If any screen share is active and we are not pinned to a different participant manually, auto stage it
            let screenSharer = null;
            participants.forEach(p => {
                if (!screenSharer && isScreenShareStream(p.stream, p.id === 'local')) screenSharer = p;
            });
            if (screenSharer) {
                if (!anyScreenShareActive()) return; // guard (shouldn't happen)
                if (pinnedParticipantId && pinnedParticipantId !== screenSharer.id) {
                    // User explicitly pinned someone else; honor that
                } else {
                    // Force stage mode if not already
                    if (stageMode !== 'pinned' || pinnedParticipantId !== screenSharer.id) {
                        if (!pinnedParticipantId) previousNonScreenStageMode = stageMode; // remember pre-screen mode
                        pinnedParticipantId = screenSharer.id;
                        stageMode = 'pinned';
                        applyStageLayout();
                    }
                }
            } else {
                // No screen share anymore; fall back if we were in a forced screen stage
                if (pinnedParticipantId && stageMode === 'pinned' && previousNonScreenStageMode !== 'pinned') {
                    pinnedParticipantId = null;
                    stageMode = previousNonScreenStageMode;
                    applyStageLayout();
                }
                _origRunActiveSpeakerDetection();
            }
        }
        
        function appendChatMessage(message, type) {
            const messageElement = document.createElement('div');
            messageElement.textContent = message;
            messageElement.classList.add('chat-message', 'p-2', 'rounded-lg', 'break-words', `${type}-message`);
            chatMessages.appendChild(messageElement);
            chatMessages.scrollTop = chatMessages.scrollHeight; // Auto-scroll
        }

        // --- Dynamic Grid Layout ---
        /******************** Adaptive Tile View Layout ************************/
        const layoutConfig = {
            targetVisibleTiles: 25,
            maxColumns: 7,
            minTileHeight: 110,
            baseAspectRatio: 16 / 9,
            portraitAspectRatio: 9 / 16,
            allowEnlargement: true,
            disableResponsive: false,
            horizontalGap: 12,
            verticalGap: 12,
            outerPaddingX: 0, // no padding so cameras can use full width
            outerPaddingY: 0,
            scrollBarAllowance: 12
        };

        function computeResponsiveGrid({
          participantCount,
          viewportWidth,
          viewportHeight,
          config
        }) {
          const {
            targetVisibleTiles,
            maxColumns,
            minTileHeight,
            baseAspectRatio,
            portraitAspectRatio,
            allowEnlargement,
            disableResponsive,
            horizontalGap,
            verticalGap,
            outerPaddingX,
            outerPaddingY
          } = config;

          const usableWidth  = viewportWidth  - outerPaddingX;
          const usableHeight = viewportHeight - outerPaddingY;

          if (participantCount === 0) {
            return emptyResult();
          }

          if (disableResponsive) {
            return simpleGrid({ participantCount, usableWidth, usableHeight, maxColumns, minTileHeight, aspect: baseAspectRatio, horizontalGap, verticalGap });
          }

          const best = { chosen: null, zeroVisible: null };
          const maxCandidateCols = Math.min(maxColumns, participantCount, targetVisibleTiles);

            for (let c = 1; c <= maxCandidateCols; c++) {
                const r = Math.ceil(participantCount / c);
                const desiredVisibleRows = participantCount <= targetVisibleTiles ? r : Math.max(1, Math.floor(targetVisibleTiles / c));
                const rawTileWidth  = (usableWidth  - (c - 1) * horizontalGap) / c;
                const rawTileHeight = (usableHeight - (desiredVisibleRows - 1) * verticalGap) / desiredVisibleRows;
                let aspect = baseAspectRatio;
                if (allowEnlargement) {
                    const viewportRatio = usableHeight / usableWidth;
                    if (viewportRatio > 1.1 || rawTileWidth < rawTileHeight) {
                        aspect = portraitAspectRatio;
                    }
                }
                let tileHeight = Math.min(rawTileHeight, rawTileWidth / aspect);
                let tileWidth  = tileHeight * aspect;
                let minHeightEnforced = false;
                if (tileHeight < minTileHeight) {
                    tileHeight = minTileHeight;
                    tileWidth  = aspect * tileHeight;
                    minHeightEnforced = true;
                    const totalWidth = tileWidth * c + horizontalGap * (c - 1);
                    if (totalWidth > usableWidth) continue;
                }
                const maxVisibleRows = Math.floor((usableHeight + verticalGap) / (tileHeight + verticalGap));
                if (maxVisibleRows <= 0) {
                    if (!best.zeroVisible) {
                        best.zeroVisible = { columns: c, rows: r, tileWidth, tileHeight, visibleRows: 0, areaScore: 0, minHeightEnforced, visibleTiles: 0 };
                    }
                    continue;
                }
                const visibleRows = Math.min(desiredVisibleRows, maxVisibleRows);
                const visibleTiles = Math.min(participantCount, visibleRows * c);
                const areaScore = tileWidth * tileHeight * visibleTiles;
                const candidate = { columns: c, rows: r, tileWidth, tileHeight, visibleRows, visibleTiles, areaScore, minHeightEnforced };
                if (!best.chosen) { best.chosen = candidate; } else {
                    const cur = best.chosen;
                    if (candidate.areaScore > cur.areaScore) {
                        best.chosen = candidate;
                    } else if (candidate.areaScore === cur.areaScore) {
                        const target = Math.min(participantCount, targetVisibleTiles);
                        const curDelta = Math.abs(cur.visibleTiles - target);
                        const candDelta = Math.abs(candidate.visibleTiles - target);
                        if (candDelta < curDelta) {
                            best.chosen = candidate;
                        } else if (candDelta === curDelta) {
                            if (candidate.tileHeight > cur.tileHeight) {
                                best.chosen = candidate;
                            } else if (candidate.tileHeight === cur.tileHeight) {
                                if (candidate.minHeightEnforced && candidate.columns > cur.columns) {
                                    best.chosen = candidate;
                                }
                            }
                        }
                    }
                }
            }
            if (!best.chosen) {
                const fb = best.zeroVisible || simpleSingleColumnFallback({ participantCount, usableWidth, usableHeight, aspect: baseAspectRatio, minTileHeight, verticalGap });
                return finalizeResult(fb, participantCount);
            }
            return finalizeResult(best.chosen, participantCount);
        }

        function simpleGrid({ participantCount, usableWidth, usableHeight, maxColumns, minTileHeight, aspect, horizontalGap, verticalGap }) {
            const columns = Math.min(Math.ceil(Math.sqrt(participantCount)), maxColumns);
            const rows = Math.ceil(participantCount / columns);
            let tileWidth = (usableWidth - (columns - 1) * horizontalGap) / columns;
            let tileHeight = tileWidth / aspect;
            if (tileHeight < minTileHeight) { tileHeight = minTileHeight; tileWidth = tileHeight * aspect; }
            const maxVisibleRows = Math.floor((usableHeight + verticalGap) / (tileHeight + verticalGap));
            const visibleRows = Math.min(rows, maxVisibleRows);
            const visibleTiles = Math.min(participantCount, visibleRows * columns);
            return finalizeResult({ columns, rows, tileWidth, tileHeight, visibleRows, visibleTiles, areaScore: tileWidth * tileHeight * visibleTiles, minHeightEnforced: tileHeight === minTileHeight }, participantCount);
        }
        function simpleSingleColumnFallback({ participantCount, usableWidth, usableHeight, aspect, minTileHeight, verticalGap }) {
            let tileWidth = usableWidth;
            let tileHeight = tileWidth / aspect;
            if (tileHeight < minTileHeight) { tileHeight = minTileHeight; tileWidth = tileHeight * aspect; }
            const maxVisibleRows = Math.floor((usableHeight + verticalGap) / (tileHeight + verticalGap));
            const visibleRows = Math.min(participantCount, maxVisibleRows);
            return { columns: 1, rows: participantCount, tileWidth, tileHeight, visibleRows, visibleTiles: visibleRows, areaScore: tileWidth * tileHeight * visibleRows, minHeightEnforced: tileHeight === minTileHeight };
        }
        function emptyResult() { return { columns: 0, rows: 0, visibleRows: 0, tileWidth: 0, tileHeight: 0, visibleTiles: 0, scrollNeeded: false }; }
        function finalizeResult(candidate, participantCount) { return { ...candidate, scrollNeeded: candidate.visibleTiles < participantCount }; }

        function debounce(fn, ms) { let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); }; }

        function adjustGrid() {
            const tiles = videoGrid.querySelectorAll('.video-container');
            const participantCount = tiles.length;
            if (!participantCount) return;

            // In any stage mode (auto or pinned) we treat the filmstrip as a simple
            // vertical list with fixed tile heights (set via CSS). We only need to
            // ensure tiles take full width and the container scrolls; we skip the
            // adaptive grid math entirely so it cannot accidentally remove scrolling
            // by forcing overflow hidden.
            if (stageMode !== 'none') {
                videoGrid.style.padding = '0';
                videoGrid.style.columnGap = '0px';
                videoGrid.style.rowGap = '0px';
                videoGrid.style.overflowY = 'auto';
                tiles.forEach(tile => {
                    tile.style.width = '100%';
                    // Let CSS important rule control height; clear inline to avoid conflicts
                    tile.style.height = '';
                });
                return;
            }

            const parentRect = videoGrid.getBoundingClientRect();
            const viewportWidth = parentRect.width;
            const viewportHeight = parentRect.height;

            // Special-case small counts: 1-3 participants => single row spanning full height for immersive feel
            if (participantCount > 0 && participantCount <= 3) {
                const gapX = layoutConfig.horizontalGap;
                const totalGapWidth = gapX * (participantCount - 1);
                const tileWidth = (viewportWidth - totalGapWidth) / participantCount;
                const tileHeight = viewportHeight; // full height usage
                videoGrid.style.padding = '0';
                videoGrid.style.columnGap = gapX + 'px';
                videoGrid.style.rowGap = '0px';
                videoGrid.style.overflowY = 'hidden';
                tiles.forEach(tile => {
                    tile.style.width = tileWidth + 'px';
                    tile.style.height = tileHeight + 'px';
                });
                return;
            }

            const layout = computeResponsiveGrid({
                participantCount,
                viewportWidth,
                viewportHeight,
                config: layoutConfig
            });

            videoGrid.style.padding = '0';
            videoGrid.style.columnGap = layoutConfig.horizontalGap + 'px';
            videoGrid.style.rowGap = layoutConfig.verticalGap + 'px';
            videoGrid.style.overflowY = layout.scrollNeeded ? 'auto' : 'hidden';

            tiles.forEach(tile => {
                tile.style.width = layout.tileWidth + 'px';
                tile.style.height = layout.tileHeight + 'px';
            });
        }

        const debouncedAdjustGrid = debounce(adjustGrid, 120);

        window.addEventListener('resize', () => {
            window.requestAnimationFrame(debouncedAdjustGrid);
        });

        // Observe size changes of video area; guard against noisy intermediate widths during chat animation
        const resizeObserver = new ResizeObserver(() => {
            if (typeof layoutSuppressedUntil === 'number' && performance.now() < layoutSuppressedUntil) return;
            debouncedAdjustGrid();
        });
        resizeObserver.observe(videoGrid);

    </script>

</body>
</html>
